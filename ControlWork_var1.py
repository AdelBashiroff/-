# 1. Сортировка слиянием требует дополнительную память размером O(n), так как на каждом этапе слияния создается временный массив для объединения отсортированных подмассивов. Это необходимо, чтобы сохранить элементы до их окончательной вставки в основной массив.
# 2. Алгоритм Tree Sort деградирует при вставке элементов в уже отсортированном порядке (или наоборот, в строго убывающем), потому что бинарное дерево становится вырожденным (по сути — списком). В лучшем случае сложность O(n log n), в худшем — O(n^2).
# 3. В TimSort минимальный размер подмассива (run) выбирается в диапазоне от 32 до 64 элементов, чаще всего используется значение 32. Это эмпирически подобранный размер, при котором сортировка вставками в пределах run работает эффективно.
# 4. В лучшем случае Bucket Sort работает за O(n) при равномерном распределении элементов по корзинам. Деградация происходит, если все элементы попадают в одну корзину — тогда сложность может вырасти до O(n^2), если в корзинах используется, например, сортировка вставками.
# 5. Сортировка Шелла — это модификация сортировки вставками, в которой сначала сравниваются и переставляются элементы на большом расстоянии, которое затем уменьшается. Главное преимущество — частичное устранение "черепах" (медленно двигающихся элементов в начале массива).
# 6. Сортировка Расческой (Comb Sort) — улучшение пузырьковой сортировки с использованием переменной "щели" (gap), которая уменьшается с каждым проходом. Деградация происходит, если используется неудачный коэффициент уменьшения gap или массив почти отсортирован.
# 7. Пирамидальная сортировка (HeapSort) имеет сложность O(n log n) в худшем, лучшем и среднем случае, так как построение кучи занимает O(n), а каждый из n удалений из кучи требует O(log n). Алгоритм стабилен по производительности.
# 8. Числа Леонардо определяются по рекурсии L(0) = 1, L(1) = 1, L(k) = L(k-1) + L(k-2) + 1. В алгоритме SmoothSort они используются для определения структуры "гребня" из куч, позволяющего эффективно адаптироваться к частично отсортированным массивам.
# 9. В оптимальном случае глубина рекурсии в Quicksort составляет O(log n), что достигается при выборе медианы в качестве опорного элемента. Для приближения к медиане можно использовать "медиану из трех" или случайный выбор опорного элемента.
# 10. IntroSort начинает с быстрой сортировки, но если глубина рекурсии становится слишком большой, переключается на HeapSort. Это позволяет сохранить O(n log n) сложность даже в худшем случае.
# 11. IntroSort решает проблему худшего случая быстрой сортировки (O(n^2)), заменяя её на пирамидальную сортировку при слишком глубокой рекурсии. Это гибрид быстрой, пирамидальной и сортировки вставками.